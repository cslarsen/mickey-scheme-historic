{"body":"Mickey R7RS Scheme\r\n==================\r\n\r\nMickey Scheme is an incomplete, slow and buggy implementation of R7RS Scheme\r\nsmall.\r\n\r\nPrivate repo?\r\n=============\r\nMickey R7RS Scheme is still being developed, but I have decided to change both name and license for the project, so I will put up a new repository soon.  In the (hopefully short) meantime, the project is private.\r\n\r\n\r\nCurrent Features\r\n----------------\r\n\r\n  * Most core Scheme functions\r\n  * Supports 164 of 240 R7RS base library definitions\r\n  * Quotation and quasiquotation\r\n  * Most `let`-forms, including named let\r\n  * Rest arguments (aka variadic functions)\r\n  * Macros (while it _does_ work, it's still incomplete)\r\n  * Lazy evaluation with memoization\r\n  * Experimental LLVM JIT compilation (for _one_ function only, currently)\r\n  * Tail call eliminiation (yeah, neither the JVM nor Python has that,\r\n    so that's at least _something_ to be a little proud of!)\r\n\r\nSome of these are demonstrated in the [example code section](#examples).\r\n\r\nExtensions to standard Scheme\r\n-----------------------------\r\n\r\nIt also has some experimental extensions to R7RS scheme:\r\n\r\n  * First class environments via the library `(mickey environment)`\r\n    ([see examples](#environments))\r\n  * Dynamic loading of shared libraries via `(mickey dynamic-library)`\r\n    ([see dlopen example](#c-libraries))\r\n\r\nCurrent Shortcomings\r\n--------------------\r\n\r\n  * It's __slow__: The code is completely interpreted, without _any_\r\n    optimizations.  I have plans to change this.\r\n\r\n  * It's __incomplete__: Some key Scheme features are still missing, and\r\n    quite some R7RS library functions (currently it supports 176 of 335\r\n    R7RS definitinos).\r\n\r\n  * It's __buggy__: There are inherent bugs in the engine as well as\r\n    erronous implementations of library functions.\r\n\r\n  * It does not collect __garbage__: Currently, there is no garbage\r\n    collector.  Adding a simple mark-and-sweep GC is trivial, though, so\r\n    I'll get to it once I think it's important enough.\r\n\r\n  * It doesn't support __continuations__ (yet):  I think I'll have to\r\n    convert to continuation passing style for a proper implementation of\r\n    this.\r\n\r\nCompiling\r\n---------\r\n\r\nRun `make -j check` to perform a simple check, then `./mickey` to play with a REPL.\r\n\r\nThe project is not really release-ready, so there is no use of autotools.\r\nThe Makefile assumes you have llvm-g++ installed.  If you want to compile\r\nusing gcc, do something like:\r\n\r\n    CXX=g++ make -ej\r\n\r\nto compile using `g++` and in parallel.\r\n\r\nFeature flags\r\n-------------\r\n\r\n  * `-DBOEHM_GC` and `-lgc` for Bohem-Demers-Weiser garbage collector\r\n     (doesn't currently work very well, though!)\r\n\r\n  * `-DUSE_READLINE` and `-lreadline` for readline support (including TAB\r\n     completion)\r\n\r\nLicense\r\n-------\r\n\r\nDistributed under the modified BSD license.\r\n\r\nAuthor\r\n------\r\n\r\nCopyright (C) 2011-2012 Christian Stigen Larsen <csl@sublevel3.org>\r\n\r\nhttp://csl.sublevel3.org\r\n\r\n## Examples\r\n\r\nHere are a few example code snippets for Mickey Scheme.  \r\n\r\nBesides demonstrating the basic capabilities of Mickey, it also serves as a\r\nkind of soft introduction to Scheme.\r\n\r\nFirst, let's start `mickey`.\r\n\r\n    $ ./mickey\r\n                                                                    _\r\n    Mickey Scheme (C) 2011-2012 Christian Stigen Larsen              \\\r\n    4.2.1 (Based on Apple Inc. build 5658) (LLVM build 2336.9.00)    /\\\r\n    Readline 4.2                                                    /  \\_\r\n                                                                          \r\n    Loaded 150 definitions\r\n    Execute (exit [ code ]) to quit\r\n    You can also (:run-tests) and (list-globals)\r\n\r\n    mickey> \r\n\r\nThis is the REPL, or _read-evaluate-print loop_.  Now, let's type some code.\r\n\r\n    mickey> (display \"Hello, world!\\n\")\r\n    Hello, world!\r\n\r\n## Lambda\r\n\r\nLet's play with lambdas.  First we'll create a lambda to square a\r\nnumber and execute it on the fly.\r\n\r\n    mickey> ((lambda (x) (* x x)) 12)\r\n    144\r\n\r\nWe can it to a variable as well.  Let's bind it to the variable `square`.\r\n\r\n    mickey> (define square (lambda (x) (* x x)))\r\n    mickey> (square 12)\r\n    144\r\n    mickey> (square 3.1415)\r\n    9.86902\r\n\r\nLet's have some fun with lambdas.  Let's create\r\na function that creates other functions.\r\n\r\nWe'll create a general function `make-adder` that\r\ncreates a function that can add a static number to another\r\nnumber.\r\n\r\n    mickey> (define make-adder\r\n              (lambda (frozen-number)\r\n                (lambda (x)\r\n                  (+ x frozen-number))))\r\n\r\nAs you can see, we give it a `frozen-number` and it returns\r\na lambda that takes a number `x` and adds the two together.\r\n\r\nSo to make a function that adds 5 to its argument, we simply\r\ndo\r\n\r\n    mickey> (define add5 (make-adder 5))\r\n    mickey> (add5 10)\r\n    15\r\n\r\nLikewise\r\n\r\n    mickey> (define add17 (make-adder 17))\r\n    mickey> (add17 10)\r\n    27\r\n\r\nWriting `(define (lambda (x) ...))` is tedious, so a\r\nshorter variant is available:\r\n\r\n    mickey> (define (cube x) (* x x x))\r\n    mickey> (cube 101)\r\n    1030301\r\n\r\nMickey uses GNU readline, so it offers both tab completion and history.  And\r\nit actually works, too.  Here we write `(ca` and hit `TAB` two times to see\r\navailable definitions.\r\n\r\n    mickey> (ca\r\n    caaar  caadr  caar   cadr   car  \r\n\r\nHere are `car` and `cdr`.  They extract the first and remaining items in a\r\nlist.\r\n\r\n    mickey> (car '(1 2 3))\r\n    1\r\n    mickey> (cdr '(1 2 3)))\r\n    (2 3)\r\n\r\nI like the old school \"car\" and \"could-er\" forms because you can compose them, so that you can extract the `car`\r\nof the `cdr` like so:\r\n\r\n    mickey> (cadr '(1 2 3))\r\n    2\r\n\r\nThey might not be very interesting for flat lists, but they shine for\r\naccessing trees.\r\n\r\n## Arithmetic\r\n\r\nHere is some simple arithmetic.\r\n\r\n    mickey> (+ 1 2 3 4 5 6 7 8 9 10)\r\n    55\r\n\r\nSummation of sequences can be calculated more quickly with\r\n\r\n    mickey> (define (seq-sum n)\r\n              (* n (/ (+ n 1) 2)))\r\n\r\nwhich gives us\r\n\r\n    mickey> (seq-sum 10)\r\n    55\r\n    mickey> (seq-sum 100)\r\n    5050\r\n    mickey> (seq-sum 127)\r\n    8128\r\n\r\n## Let-forms\r\n\r\nHere is an example of the \"let star\" form.  It creates a local variable\r\nscope, and evaluates them in the given order.\r\n\r\n    mickey> (let* ((x 2)\r\n                   (y 3)\r\n                   (z (* x y)))\r\n                   (display z))\r\n\r\nThis, of course, prints `6`.\r\n\r\nThere is also a `letrec` form that allows for mutually recursive\r\ndefinitions.  Or in plain english, expressions that refer to each other.\r\n\r\nThe typical example of this is to implement `even?` and `odd?` in terms of\r\neach other:\r\n\r\n* A number is _even_ if the preceding number is odd, and\r\n* A number is _odd_ if the preceding number is even\r\n\r\nSince our definition is going to be mutually recursive, we need to handle\r\nbase cases of zero (negative values will make the code loop forever, though).\r\n\r\nLet's write that out, along with a `check-number` function.\r\n\r\n    (letrec\r\n      ((even? (lambda (n)\r\n                (if (zero? n) #t\r\n                    (odd? (- n 1)))))\r\n\r\n       (odd? (lambda (n)\r\n               (if (zero? n) #f\r\n                   (even? (- n 1)))))\r\n\r\n       (check-number\r\n         (lambda (n)\r\n           (display `(The number ,n is ,(if (even? n) 'even 'odd)))\r\n           (newline))))\r\n\r\n       (check-number 2)\r\n       (check-number 3)\r\n       (check-number 88)\r\n       (check-number 99))\r\n\r\nIf you run the above code in `mickey`, you'll get this output:\r\n\r\n    (The number 2 is even)\r\n    (The number 3 is odd)\r\n    (The number 88 is even)\r\n    (The number 99 is odd)\r\n\r\n## Macros\r\n\r\nNow, Scheme doesn't have a `when` function.  The `when` function checks\r\nwhether the first argument is true.  If it is, then it will evaluate --- or\r\nexecute --- the code given in the remaining arguments.\r\n\r\nYou can't do this with a simple function, because it would *always* evaluate\r\nthe code body.  As an example, let's say we have a boolean variable\r\n`green-light`.  If it's `true`, we'll format the hard drive:\r\n\r\n    (when green-light (format-drive))\r\n\r\nIf `when` was implemented as a function, it would always format the hard drive,\r\nbecause function parameters must be evaluated _before_ entering the function\r\nitself.\r\n\r\nIt is clear that we need a way to _control evaluation_.  Scheme's macros\r\nwill let ut do exactly that.\r\n\r\nSo let's implement `when` as a hygienic macro.\r\n\r\n    mickey> (define-syntax when\r\n              (syntax-rules ()\r\n                ((when test expr ...)\r\n                  (if test (begin expr ...)))))\r\n\r\nThat's it.  To demonstrate that we control the evaluation, let's create a\r\nfunction with a side effect that prints to the console when it's evaluated.\r\n\r\n    mickey> (define (say-hello) (display \"Hello\\n\"))\r\n    mickey> (say-hello)\r\n    Hello\r\n\r\nCalling\r\n\r\n    mickey> (when #f (say-hello))\r\n\r\ndoes not print anything, which is good.  In contrast,\r\n\r\n    mickey> (when #t (say-hello))\r\n    Hello\r\n\r\ndoes indeed print to the console.\r\n\r\n## Quotation\r\n\r\nNow let's try some examples with quasi-quotation.  Since Scheme is a\r\nsymbolic language, we can easily create syntax trees for languages like SQL\r\nby just using quotation.  But sometimes we'll want to embed actual\r\ncomputations into them, so therefore we can use the specual `unquote` prefix\r\nwith a comma.\r\n\r\nHere is an example of just that.\r\n\r\n    mickey> (define (sql-get-user name)\r\n              `(select * from user where name = ,name))\r\n\r\n*Note*: _There is currently a bug in the mickey REPL, so that\r\nquasiquotation requires an extra closing parenthesis to parse.  \r\nThis bug is not present if you run this example from a file, though._\r\n\r\nRunning the function should be self-explanatory.\r\n\r\n    mickey> (sql-get-user \"foo\")\r\n    (select * from user where name = \"foo\")\r\n\r\nFurthermore, sometimes we want to splice two lists together when we quote.\r\nWe can do that by using unquote splice, or the `,@` prefix.\r\n\r\n    mickey> (define date '(2012 05 17))\r\n    mickey> date\r\n    (2012 5 17)\r\n    mickey> `(here is a date: ,@date)\r\n    (here is a date: 2012 5 17)\r\n\r\n## Lazy evaluation\r\n\r\nMickey Scheme also supports delayed -- or lazy -- evaluation.  That is,\r\ncomputations that are not executed right away.\r\n\r\nIn fact, all languages that support evaluation control (for instance, via a\r\nmacro facility) and first class closures should be able to *implement* lazy\r\nevaluation without any external library.\r\n\r\nLet's create a list `queue` that contains some code we want to execute at a\r\nlater time.\r\n\r\n    (define queue\r\n      (list (delay (display \"One! \"))\r\n            (delay (display \"Three! \"))\r\n            (delay (display \"Two! \"))))\r\n\r\nNow we want to execute the code in the list, but reordered so that it will\r\nprint \"One! Two! Three!\":\r\n\r\n    (force (list-ref queue 0))\r\n    (force (list-ref queue 2))\r\n    (force (list-ref queue 1))\r\n\r\nThis outputs:\r\n\r\n    One! Two! Three!\r\n\r\n# Extensions\r\n\r\nFor debugging purposes, I've added some extension functions only available\r\nto Mickey Scheme.\r\n\r\n## (:syntax-expand _code_)\r\n\r\nIf you want to see how a macro is expanded, you can use\r\n`(:syntax-expand ...)`.  Below is an example.\r\n\r\n    mickey> (define-syntax my-when\r\n              (syntax-rules ()\r\n                  ((my-when test expr ...)\r\n                        (if test (begin expr ...)))))\r\n    mickey> (:syntax-expand '(my-when #t 123))\r\n    (if #t (begin 123))\r\n    mickey> (:syntax-expand '(my-when #f 123))\r\n    (if #f (begin 123))\r\n\r\n## (:debug ...)\r\n\r\nReturns string with printable debug information.\r\n\r\n    mickey> (display (:debug \"foo\"))\r\n    adr=0x7fe501536560 type=pair    car=0x7fe501536340 cdr=0x7fe501536540\r\n    adr=0x7fe501536340 type=string  value='foo'\r\n    adr=0x7fe501536540 type=nil   \r\n\r\n## (:type-of ...)\r\n\r\nPrints what type Mickey determines the expression to be.\r\n\r\n    mickey> (:type-of 123)\r\n    integer\r\n    mickey> (:type-of '())\r\n    pair\r\n    mickey> (:type-of \"hey\")\r\n    string\r\n\r\n## (:list->dot ...)\r\n\r\nConvert the given expressions to Graphviz dot(1) format, which will display\r\na graph of the cons cells.\r\n\r\n    mickey> (display (:list->dot '(root (left-child (left-grandchild) (right-child)))))\r\n    digraph Scheme {\r\n      \"0x7fefeaceaca0\":head -> \"0x7fefeaceab40\":head [\"ol\"=\"box\"];\r\n      \"0x7fefeaceab40\":head -> \"0x7fefeace9cf0\" [\"ol\"=\"box\"];\r\n      \"0x7fefeace9cf0\" [label=\"root\", shape=\"none\"];\r\n      \"0x7fefeaceab40\":tail -> \"0x7fefeaceab20\":head [\"ol\"=\"box\"];\r\n      \"0x7fefeaceab20\":head -> \"0x7fefeaceab00\":head [\"ol\"=\"box\"];\r\n      \"0x7fefeaceab00\":head -> \"0x7fefeace9d50\" [\"ol\"=\"box\"];\r\n      \"0x7fefeace9d50\" [label=\"left-child\", shape=\"none\"];\r\n      \"0x7fefeaceab00\":tail -> \"0x7fefeaceaae0\":head [\"ol\"=\"box\"];\r\n      \"0x7fefeaceaae0\":head -> \"0x7fefeacea9c0\":head [\"ol\"=\"box\"];\r\n      \"0x7fefeacea9c0\":head -> \"0x7fefeacea020\" [\"ol\"=\"box\"];\r\n      \"0x7fefeacea020\" [label=\"left-grandchild\", shape=\"none\"];\r\n      \"0x7fefeacea9c0\" [label=\"<head>|<tail>\", shape=\"record\"];\r\n      \"0x7fefeaceaae0\":tail -> \"0x7fefeaceaac0\":head [\"ol\"=\"box\"];\r\n      \"0x7fefeaceaac0\":head -> \"0x7fefeaceaaa0\":head [\"ol\"=\"box\"];\r\n      \"0x7fefeaceaaa0\":head -> \"0x7fefeaceaa20\" [\"ol\"=\"box\"];\r\n      \"0x7fefeaceaa20\" [label=\"right-child\", shape=\"none\"];\r\n      \"0x7fefeaceaaa0\" [label=\"<head>|<tail>\", shape=\"record\"];\r\n      \"0x7fefeaceaac0\" [label=\"<head>|<tail>\", shape=\"record\"];\r\n      \"0x7fefeaceaae0\" [label=\"<head>|<tail>\", shape=\"record\"];\r\n      \"0x7fefeaceab00\" [label=\"<head>|<tail>\", shape=\"record\"];\r\n      \"0x7fefeaceab20\" [label=\"<head>|<tail>\", shape=\"record\"];\r\n      \"0x7fefeaceab40\" [label=\"<head>|<tail>\", shape=\"record\"];\r\n      \"0x7fefeaceaca0\" [label=\"<head>|<tail>\", shape=\"record\"];\r\n    }\r\n\r\nIf you write the output to a file, you can render it with `dot(1)`:\r\n\r\n    $ dot -Tpng -ofoo.png foo.dot\r\n\r\n## (:closure-source ...)\r\n\r\nReturns the quoted source for a given closure.  Example:\r\n\r\n    mickey> (define (sq x) (* x x))\r\n    mickey> (:closure-source sq)\r\n    (lambda (x) (begin (* x x)))\r\n    mickey> ((eval (:closure-source sq)) 12)\r\n    144\r\n\r\n## (:version)\r\n\r\nDisplays version number for Mickey and libraries.\r\n\r\n    mickey> (display (:version)) (newline)\r\n    (Mickey Scheme (C) 2011 Christian Stigen Larsen\r\n     Using Readline 4.2\r\n      Compiler version: 4.2.1 (Based on Apple Inc. build 5658) (LLVM build\r\n      2336.9.00)\r\n      )\r\n\r\n## (:exit _code_)\r\n\r\nExit Mickey, returning given code to the parent process.\r\n\r\n## Environments\r\n\r\nMickey Scheme has an experimental library for first-class environments.\r\nIt bascially implements the API from MIT Scheme, with a few missing\r\nfeatures.\r\n\r\nHere is an example on how to use it.\r\n\r\nFirst, let's start up mickey with an empty environment (the -z argument).\r\nAn empty environment means that the REPL only has one definition, that of\r\n`import`.  We need `import` because to do anything, we need to be able to\r\nimport libraries.\r\n\r\n    csl$ ./mickey -z\r\n    #|                                                                 _\r\n       Mickey Scheme (C) 2011-2012 Christian Stigen Larsen              \\\r\n       4.2.1 (Based on Apple Inc. build 5658) (LLVM build 2336.11.00)   /\\\r\n       Readline 4.2                                                    /  \\_\r\n\r\n       To quit, hit CTRL+D or type (exit).  Use (help) for an\r\n       introduction.\r\n    |#\r\n\r\nNow, let's just make sure that we don't have any binding for `foo`.\r\n\r\n    #; mickey> foo\r\n    Unbound definition: foo\r\n\r\nLet's import the `(mickey environment)` library and define `foo` in a new\r\nenvironment that is a child of the current one.\r\n\r\n    #; mickey> (import (mickey environment))\r\n    #; mickey> (define sub-environment\r\n                         (make-environment\r\n                           (define foo 123)))\r\n\r\nWe still should not see `foo` in the current environment:\r\n\r\n    #; mickey> foo\r\n    Unbound definition: foo\r\n\r\nBut it should be available in the environment we have stored in the variable\r\n`sub-environment`.\r\n\r\n    #; mickey> (environment-bindings sub-environment)\r\n    ((foo 123))\r\n\r\nLet's import the `(scheme write)` library so we can call `display`, and then\r\nonly the `newline` function from `(scheme base)`.\r\n\r\n    #; mickey> (import (scheme write))\r\n    #; mickey> (import (only (scheme base) newline))\r\n\r\nNow, let's evaluate an expression in the child environment to print the\r\nvalue of `foo`:\r\n\r\n    #; mickey> (environment-eval \r\n                 (begin\r\n                   (display foo)\r\n                   (newline)) sub-environment)\r\n    123\r\n    #; mickey> ^D\r\n\r\nSo, what's the point with first class environments?  You can use it do to\r\nstuff like implementing your own module system.  The reason they are not\r\npart of standard Scheme is because they make it very difficult to reason\r\nabout what a program does just by reading the code.\r\n\r\nTherefore, implementations are allowed to implement them on their own.\r\n\r\n## C-libraries\r\n\r\nIt's possible to write libraries in C and call them from Mickey Scheme.\r\n\r\nSince Mickey does not use a build system yet, the process is a little bit\r\ncumbersome.\r\n\r\nFirst you write a small library in C.  Let's say we want to be able to call\r\nthe `uname(3)` function from Mickey.  We'll just write some wrapper code in\r\nC:\r\n\r\n    #include <sys/utsname.h>\r\n    #include \"mickey-api.h\"\r\n\r\n    cons_t* proc_uname(cons_t* args, environment_t* env)\r\n    {\r\n      struct utsname p;\r\n\r\n      if ( uname(&p) != 0 )\r\n        return boolean(false);\r\n\r\n      // Return utsname as an associative list\r\n      return\r\n        cons(cons(symbol(\"sysname\",  NULL), cons(string(p.sysname))),\r\n        cons(cons(symbol(\"nodename\", NULL), cons(string(p.nodename))),\r\n        cons(cons(symbol(\"release\",  NULL), cons(string(p.release))),\r\n        cons(cons(symbol(\"version\",  NULL), cons(string(p.version))),\r\n        cons(cons(symbol(\"machine\",  NULL), cons(string(p.machine))))))));\r\n    }\r\n\r\nNote that if you use a C++ compiler with the above code, you must prefix the\r\nfunction with `extern \"C\"` to avoid the infamous C++ name-mangling.\r\n\r\nNow, compiling this should ideally be straightforward, something á la\r\n\r\n    gcc -shared -Imickey-include/ mickey-uname.c \\\r\n        -lmickey-api -o libmickey-uname.so\r\n\r\nUnfortunately, I've not made a proper mickey library yet, so you actually\r\nhave to include all the object files.  See the Makefile for details.\r\n\r\nAnyway, after compilation you've got a libmickey-uname.so file.  To load\r\nthis file from Mickey, we have to start mickey and then import the `(mickey\r\ndynamic-library)` library.\r\n\r\n    csl$ ./mickey\r\n    #|                                                                 _\r\n       Mickey Scheme (C) 2011-2012 Christian Stigen Larsen              \\\r\n       4.2.1 (Based on Apple Inc. build 5658) (LLVM build 2336.11.00)   /\\\r\n       Readline 4.2                                                    /  \\_\r\n\r\n       To quit, hit CTRL+D or type (exit).  Use (help) for an\r\n       introduction.\r\n    |#\r\n    \r\n    #; mickey> (import (mickey dynamic-library))\r\n\r\nLet's load the library using the dlopen options RTLD_NOW and RTLD_LOCAL.\r\nYou can omit the options to use default dlopen mode.  I'm just showing you\r\nhow to specify several options.\r\n\r\n    #; mickey> (define lib-uname (dlopen \"libmickey-uname.so\" 'now 'local))\r\n\r\nNow `lib-uname` contains a handle to the library.\r\n\r\n    #; mickey> lib-uname\r\n    #<pointer 'dynamic-shared-library-handle' 0x7ffb63436460>\r\n\r\nLet's get a reference to the `proc_uname` function and bind that to the\r\nvariable `uname`:\r\n\r\n    #; mickey> (define uname (dlsym lib-uname \"proc_uname\"))\r\n\r\nIf `dlsym` fails, it will return `#f`.  Let's see if it worked:\r\n\r\n    #; mickey> uname\r\n    #<closure 0x7ffb6343b550>\r\n\r\nIt did!  Let's try executing it.\r\n\r\n    #; mickey> (uname)\r\n     ((sysname \"Darwin\") (nodename \"Christians-mac-8.local\") (release \"12.0.0\")\r\n     (version \"Darwin Kernel Version 12.0.0: Sun Jun 24 23:00:16 PDT 2012;\r\n     root:xnu-2050.7.9~1/RELEASE_X86_64\") (machine \"x86_64\"))\r\n\r\nIt returns the struct as an a-list, so we can do\r\n\r\n    #; mickey> (assv 'version (uname))\r\n    (version \"Darwin Kernel Version 12.0.0: Sun Jun 24 23:00:16 PDT 2012;\r\n    root:xnu-2050.7.9~1/RELEASE_X86_64\")\r\n\r\nand\r\n\r\n    #; mickey> (assv 'machine (uname))\r\n    (machine \"x86_64\")\r\n\r\nEasy!\r\n","name":"Mickey-scheme","google":"","note":"Don't delete this file! It's used internally to help with page regeneration.","tagline":"Mickey Scheme is an incomplete interpreter for R7RS Scheme written in C++"}