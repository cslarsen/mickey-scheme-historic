BUGS
- Big bugs in "make check".  Don't know what's going on, but could be
  heap corruption.
- Run "(4 5)" and "(vector 1 2 (3 4))" works fine.  Fix in invoke().
- Fix TRY-CATCH jump implementation (TRY=excepation_raised()+goto)
- Update append() in primops to be same as idiom in proc_vector_to_list.

RANDOM STUFF

NEXT STEPS, SHOULD BE ORDERED BY INCREASING DIFFICULTY
- In closure_t, add "cons_t *args, *body" instead of using __args__ and __body__
- Add module system (module, export, import, etc)
- Put as many functions as possible into the base module
- Add let-syntax
- Fix define-syntax / syntax rules: LOTS of bugs in the macro system
- Add more recognized patterns in syntax-rules
- Add letrec*
- Add let-values
- Add let*-values
- Fix native string type; using C-string doesn't work with make-string 10 #\nul
- Add simple mark-and-sweep GC (simple; currently not needed)
- Add tail call elimination (possibly using CPS)
- Look into exact->inexact stuff
- Add continuation passing style (CPS) transform for all code
- Refactor the code, it's A MESS at the moment...
- Fix expt for fractional exponents
- Add support for continuations
- Add call/cc
- Add support for first class continuations
- Add memoization to lazy evaluation form
- Add UTF8 support for strings
- Add UTF8 support for define names (if allowed by r7rs)

LATER / HARDER
- Add library functions
- Add libffi support
- Add llvm primitives in scheme
- Craft llvm compiler (in scheme?)
- Add (fast) vector/SSE support through #(1 2 3)
- Add parallelization support (through some lib; see comp benchmarks game)

LLVM
Make all llvm primitives callable by interpreter, i.e.
implement functions as llvm primitives, e.g.:

  (define display
    (lambda (p)
      (while (not (null? p))
        (begin
          (if (not (pair? p))
            (ffi:printf "%s" (->c_string p))
            (display (eval (car p))))
          (set! p (cdr p))))))

Some functions must be built-in, I guess, like "no", "null?", "->c_string"
and so on.  But perhaps later on, these can as well become something that
can be implemented (?).  (At least many of them).
