TODO
- Allow #true and #false as #t and #f, but currently we can to #tfoo and
  #ffoo, so fix that
- Apparently, this is not allowed in r7rs: "1.2f" to donate floats, or "2f"
- Allow |foo bar| identifiers, e.g. (define (|hello world| message) (display message))
- Enforce rules for names of definitions. E.g., this is not ok: (define (1+ num) (+ 1 num))
- Reader notation for vectors: repl> #(1 2 3)
- Should this work (does in chibi-scheme): repl> #(1 2 foo)
- Reader notation for: repl> '#(1 2 foo)
- Regarding vectors passed to functions expecting lists, find out the
  exact differences... i.e., read up on vectors
- Add third param to assoc, being the equality operator: (assoc 2.0 '((2 two) (3 three)) =)
- Add (string-ci=?)
- Add (list-set!)
- Add (inexact->exact)
- Add (make-list)
- Add (string->number <string> <opt2>), takes <opt2> option, (radix?)
- Add (call-with-values)
- Add (denominator)
- Add (numerator)
- Add (remainder)
- Add (exact?)
- Add (inexact?)
- Add (exact-integer?)
- Add (rational?)
- Add (complex?)
- Add (letrec-syntax)
- Add (let-syntax) ; almost same as define-syntax, so should be asy
- Add ,@(...) support.  Same as ,(...) BUT it does not cons(...) its result
- Add (stream-filter)
- Add (make-parameter)
- Add (parameterize)
- Add (lazy) (didn't know this was a function?)
- Add (let*-values)
- Add (letrec*)
- Add (case)
- Add (assv)
- Add "#(1 2 3)" -> "(make-vector 1 2 3)"
- Fix (delay) doesn't work properly; can do (define foo (delay (+ 1 2 3))) and then (foo) ==> 6, but that shouldn't evaluate.
- Add parsing of quoted vectors, i.e.: '#(1 2 3)
- Trampoline more stuff in eval()
- Add PROPER support for '()
- Add for-each
- Add vector-map
- Add vector-for-each
- Add support for case-folding and other hash-bang stuff
- REPL: If expression hasn't been closed, wait for more lines.
- Add support for '#(1 2 3)
- Add support for '#u8(1 2 3)
- Add eqp() support for vectors
- Add eqp() support for pairs (lists)
- Run "(4 5)" and "(vector 1 2 (3 4))" works fine.  Fix in invoke().
- Fix TRY-CATCH jump implementation (TRY=excepation_raised()+goto)
- Update append() in primops to be same as idiom in proc_vector_to_list.

RANDOM STUFF

NEXT STEPS, SHOULD BE ORDERED BY INCREASING DIFFICULTY
- In closure_t, add "cons_t *args, *body" instead of using __args__ and __body__
- Add module system (module, export, import, etc)
- Put as many functions as possible into the base module
- Add let-syntax
- Fix define-syntax / syntax rules: LOTS of bugs in the macro system
- Add more recognized patterns in syntax-rules
- Add letrec*
- Add let-values
- Add let*-values
- Fix native string type; using C-string doesn't work with make-string 10 #\nul
- Add simple mark-and-sweep GC (simple; currently not needed)
- Look into exact->inexact stuff
- Add continuation passing style (CPS) transform for all code
- Refactor the code, it's A MESS at the moment...
- Fix expt for fractional exponents
- Add support for continuations
- Add call/cc
- Add support for first class continuations
- Add memoization to lazy evaluation form
- Add UTF8 support for strings
- Add UTF8 support for define names (if allowed by r7rs)

LATER / HARDER
- Add library functions
- Add libffi support
- Add llvm primitives in scheme
- Craft llvm compiler (in scheme?)
- Add (fast) vector/SSE support through #(1 2 3)
- Add parallelization support (through some lib; see comp benchmarks game)

LLVM
Make all llvm primitives callable by interpreter, i.e.
implement functions as llvm primitives, e.g.:

  (define display
    (lambda (p)
      (while (not (null? p))
        (begin
          (if (not (pair? p))
            (ffi:printf "%s" (->c_string p))
            (display (eval (car p))))
          (set! p (cdr p))))))

Some functions must be built-in, I guess, like "no", "null?", "->c_string"
and so on.  But perhaps later on, these can as well become something that
can be implemented (?).  (At least many of them).
