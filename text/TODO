- Add memoization to lazy evaluation form
- Add letrec*, let-values, let*-values
- Fix expt for fractional exponents
- Look into exact->inexact stuff

NEXT STEPS, SHOULD BE ORDERED BY INCREASING DIFFICULTY
- Add character table
- Add our own stop-the-world, mark-and-sweep GC (is very simple for a language like scheme!)
- Add missing LET forms
  - Named let:
      (let foo
        (begin
          (display "bar\n")
          (foo)))
  - Other let forms:
    - letrec*
    - let-values
    - let*-values
- Add nested comments, #| .... |# .. also find out how nesting works, i.e., can we do #| .. #| .. |# .. |#
   (it says "properly nested #| and |# pairs", so I guess the count needs to be equal for each corresponding #| |#?)
- Add continuation passing style (CPS) transform for all code
  - Add tail call elimination via CPS
- Refactor the code, it's A MESS at the moment...

HARDER
- Add library functions
- Add libffi support
- Add llvm primitives in scheme
- Craft llvm compiler (in scheme?)
- Add (fast) vector/SSE support through #(1 2 3)
- Add parallelization support (through some lib; see comp benchmarks game)
- Check up Hewitt's actor model, how it was solved in scheme
- Add support for continuations
- Add support for first class continuations

NEXT STEPS
- Make all llvm primitives callable by interpreter
  => implement functions as llvm primitives, e.g.:

    (define display
      (lambda (p)
        (while (not (null? p))
          (begin
            (if (not (pair? p))
              (ffi:printf "%s" (->c_string p))
              (display (eval (car p))))
            (set! p (cdr p))))))

  Some functions must be built-in, I guess, like "no", "null?", "->c_string" and so on.
  But perhaps later on, these can as well become something that can be implemented (?).
  (At least many of them).

DOWN THE LINE
- Add utf-8 support for strings, consider making it default (also in variable-names? check the standard)
- Tail-call optimization
- continuations: call/cc
- Macros
