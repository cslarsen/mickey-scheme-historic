R4RS, http://people.csail.mit.edu/jaffer/r3rs_toc.html

In above doc, check out derivec expression types.

SUPPORTED STUFF:
YES: quote <datum>
YES: lambda <formals> <body> -> usikker om <formals> KAN være empty list ()
YES: if <test> <consequent> <alternate>
YES: set! <variable> <expression>, expr is eval'ed, result unspec
YES: cond
YES: and
YES: or
YES: let
YES: begin
YES: define
YES: set!
YES: not
YES: boolean?
YES: eq? -> pointer sammenligning, KAN gjerne sjekke verdi for tall, kan KUN returnere #t når eqv gjør det, så er nesten like
YES: pair?
YES: cons
YES: car
YES: null?
YES: list
YES: length
YES: append
YES: symbol?
YES: number?
YES: integer?
YES: zero?
YES: char?
YES: =
YES: <
YES: >
YES: + a b
YES: + a
YES: *
YES: - a b
YES: / 
YES: string?
YES: procedure?
YES: apply proc args
YES: write -> BUT is wrong, writes to stdout
YES: display obj
YES: newline
YES: load
YES: if <test> <consequent>
YES: number->string
YES: let*
YES: set-car!
YES: set-cdr!
YES: reverse (but does it work for lists of lists?, e.g (reverse (list 1 2 (list 3 4)))

UNSUPPORTED STUFF:

NO: '<datum>
NO: case -> trenger eqv? og memv for å få til en enkel transformasjon
NO: letrec -> tror dette går fint med eksisterende let, den er rekursiv tror jeg
NO: named let
NO: delay
NO: quasiquote
NO: nil and t -> some implementations provide nil and t, nil og 'nil => nil, t => #t
NO: eqv? basic design: per default, sammenlign POINTERS; men for tall, osv, sammenlign verdi
NO: equal? recursively compare contants of pair, vector, osv.. så denne er "ekte": Rule of thumb: er equal hvis de printes til det samme
NO: caar...cdddar
NO: cadr...cddddr
NO: list-tail
NO: list-ref, returns kth element of list
NO: last-pair
NO: memq
NO: memv
NO: member
NO: assq
NO: assv
NO: assoc
NO: symbol->string
NO: string->symbol
NO: complex?
NO: real? (eller?)
NO: rational?
NO: positive?
NO: negative?
NO: odd?
NO: even?
NO: exact?
NO: inexact?
NO: <=
NO: >=
NO: max
NO: min
NO: / that gives rational number
NO: abs
NO: quotient
NO: remainder
NO: modulo
NO: numerator
NO: denominator
NO: gcd
NO: lcm
NO: floor
NO: ceiling
NO: truncate
NO: round
NO: rationalize x y
NO: rationalize x
NO: exp
NO: log
NO: sin
NO: cos
NO: tan
NO: asin
NO: acos
NO: atan z
NO: atan y x
NO: sqrt
NO: expt
NO: make-rectangular
NO: make-polar
NO: real-part
NO: imag-part
NO: magnitude
NO: angle
NO: exact->inexact
NO: inexact->exact
NO: string->number
NO: char=?
NO: char<?
NO: char>?
NO: char<=?
NO: char>=?
NO: char-ci=?
NO: char-ci<?
NO: char-ci>?
NO: char-ci<=?
NO: char-ci>=?
NO: char-alphabetic?
NO: char-numeric?
NO: char-whitespace?
NO: char-upper-case?
NO: char-lower-case?
NO: char->integer
NO: integer->char
NO: char-upcase
NO: char-downcase
NO: make-string k
NO: make-string k char
NO: string-length
NO: string-ref
NO: string-set!
NO: string=?
NO: string-ci=?
NO: string<?
NO: string>?
NO: string<=?
NO: string>=?
NO: string-ci<?
NO: string-ci>?
NO: string-ci<=?
NO: string-ci>=?
NO: substring
NO: string-append
NO: string->list
NO: list->string
NO: string-copy
NO: string-fill!
NO: vector?
NO: make-vector k
NO: make-vector k fill
NO: vector
NO: vector-length
NO: vector-ref
NO: vector-set!
NO: vector->list
NO: list->vector
NO: apply proc arg1 ... args
NO: map proc list
NO: map proc list1 list2 ...
NO: for-each proc list
NO: for-each proc list1 list2
NO: force <promise>
NO: call-with-current-continuation
NO: call-with-input-input-file string proc
NO: call-with-output-file string proc
NO: input-port?
NO: output-port?
NO: current-input-port
NO: current-output-port
NO: with-input-from-file
NO: with-output-to-file
NO: open-input-file
NO: open-output-file
NO: close-input-port
NO: close-output-port
NO: read
NO: read port
NO: read-char
NO: char-ready?
NO: char-ready? port
NO: eof-object? obj
NO: write obj port
NO: display obj port
NO: newline port
NO: write-char
NO: write-char
NO: transcript-on filename
NO: transcript-off
